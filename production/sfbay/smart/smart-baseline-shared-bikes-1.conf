include "smart-baseline.conf"

beam.agentsim.firstIteration = 0
#reposition only happen when there are more than 0 iteration
beam.agentsim.lastIteration = 5
#downsample of population
beam.agentsim.agentSampleSizeAsFractionOfPopulation = 0.1

#activitysim base----need to confirm
#merge activity’s 2010 plans with urbansim’s -- PILATES run.
#skims_fname: gemini/10.activitySimODSkims.UrbanSim.TAZ.Full.csv.gz The full skim file that contains all Origin Destinations pairs with ActivitySim path types.
#beam_config: gemini/activitysim-base-from-60k-input.conf Path to beam config. This path must be relative to beam_local_input_folder and region. The BEAM docker container is provided with this config as an input.
#beam_plans: gemini/activitysim-plans-base-2010-cut-60k/plans.csv.gz File with BEAM plans that is going to be replace with the ActiveSim output.
#beam_local_input_folder: pilates/beam/production/ Path to BEAM input folder. This folder is going to be mapped to the BEAM container input folder.
#beam_local_output_folder: pilates/beam/beam_output/ The BEAM output is going to be saved here. In order to have a clean run this directory should be empty before start.
##https://github.com/ual/PILATES
beam.router.skim = {
  # This allows to write skims on each iteration
  writeSkimsInterval = 1
}

#beam.exchange{
#  output {
#    # this disables saving activitySim Skims
#    activitySimSkimsEnabled = false
#    # geo level different than TAZ (in beam taz-centers format)
#    geo.filePath = ${beam.inputDirectory}"/block_group-centers.csv.gz"
#  }
#}
# This loads linkStats from the last found BEAM runs
beam.warmStart.type = "linkStatsFromLastRun"
# For subsequential beam runs (some data will be laoded from the latest found run in this directory)
beam.input.lastBaseOutputDir = ${beam.outputs.baseOutputDirectory}
# This prefix is used to find the last run output directory within beam.input.lastBaseOutputDir direcotry
beam.input.simulationPrefix = ${beam.agentsim.simulationName}
# fraction of input plans to be merged into the latest output plans (taken from the beam.input.lastBaseOutputDir)
beam.agentsim.agents.plans.merge.fraction = 0.2
##take initial activities and do mode choice within beam

#generate second activity
#beam.agentsim.agents.tripBehaviors.mulitnomialLogit.generate_secondary_activities = true


##################################################################
# Agentsim
##################################################################
#decide the time diviation..



beam.agentsim.simulationName = "sfbay-dockless-baseline"

beam.exchange.scenario {
  # source for now can be "MATSim" or "UrbanSim"
  source = "urbansim_v2"
  # Input file format for scenario loader can be "csv" or "parquet"
  fileFormat = "csv"
  folder = ${beam.inputDirectory}"/../ActivitySim"
  convertWgs2Utm = true
}

##banning car
#beam.agentsim.agents.tripBehaviors.carUsage.minDistanceToTrainStop=1609.344

beam.physsim.skipPhysSim = false

beam.debug {
  debugEnabled = false
  vmInformation.createGCClassHistogram = false
  writeModeChoiceAlternatives = false
}

beam.agentsim.agents.vehicles.vehicleTypesFilePath = ${beam.inputDirectory}"/../smart/vehicle-tech/vehicletypes-baseline-different-price.csv"
beam.agentsim.agents.vehicles.fractionOfPeopleWithBicycle=0.1

beam.agentsim.agents.vehicles.sharedFleets = [
  {
    name = "bay_wheels"
    managerType = "fixed-non-reserving-fleet-by-taz"
    parkingFilePath = ${beam.inputDirectory}"/../parking/shared-bike-parking-hubs-1454.csv"
    #@optional
    fixed-non-reserving-fleet-by-taz {
      vehicleTypeId = "sharedBike",
      vehiclesSharePerTAZFromCSV = ${beam.inputDirectory}"/../parking/shared-bike-initial-1454.csv",
      maxWalkingDistance = 500,
#      //https://mtc.ca.gov/operations/traveler-services/bay-wheels-bike-share-program
      fleetSize = 15000

    }
    #try at least one---only baseline within and without
    #@optional
#    reposition {
#      name = "min-availability-undersupply-algorithm"
#      #min-availability-observed-algorithm
#      #min-availability-undersupply-algorithm
#      min-availability-undersupply-algorithm = {
#        matchLimit = 5
#      }
#      repositionTimeBin = 3600,
#      statTimeBin = 300,
#      AvailabilityBasedRepositioning {
#        matchLimit = 5
#      }
#    }


  }
]